----- CCFG (from here) -----
Class Name = Tetris
   0 fieldEntry [ Tetris#timer ]
   1 fieldDeclaration D = { this.timer } U = { this.timer }
   2 fieldExit
--
   0 methodEntry [ Tetris#stopTimer( ) ]
   1 assignment D = { this.timer } U = {  }
   2 methodExit
   3 formalOut D = {  } U = { $_ }
--
   0 constructorEntry [ Tetris#Tetris( ) ]
   1 constructorExit
   2 formalOut D = {  } U = { $_ }
--
   0 methodEntry [ Tetris#init( ) ]
   1 assignment D = { this.info } U = { GameInfo.!GameInfo( ) }
   2 receiver D = {  } U = {  }
   3 constructorCall D = {  } U = { GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).width, GameInfo.rows, Tile.SIZE, this.!java.awt.Component.x, this.!java.awt.Component.y } TO = GameInfo#GameInfo( )
   4 actualOut D = { GameInfo.!GameInfo( ) } U = { GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).width, GameInfo.rows, Tile.SIZE, this.!java.awt.Component.x, this.!java.awt.Component.y }
   5 assignment D = { this.pit } U = { Pit.!Pit( GameInfo ) }
   6 receiver D = {  } U = {  }
   7 constructorCall D = {  } U = { Pit.!Pit( GameInfo ).height, Pit.!Pit( GameInfo ).width, Pit.columns, Pit.java.util.Random.!java.util.Random.seed, Pit.rows, Tile.SIZE, i$0.font, i$0.height, i$0.level, i$0.lines, i$0.offImage, i$0.offg, i$0.score, i$0.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.!java.lang.Runtime.currentRuntime } TO = Pit#Pit( GameInfo )
   8 actualIn D = {  } U = { GameInfo.!GameInfo( ).font, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).level, GameInfo.!GameInfo( ).lines, GameInfo.!GameInfo( ).offImage, GameInfo.!GameInfo( ).offg, GameInfo.!GameInfo( ).score, GameInfo.!GameInfo( ).width, this.info, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.offImage, this.info.offg, this.info.score, this.info.width }
* actualOut D = { Pit.!Pit( GameInfo ), Pit.java.util.Random.!java.util.Random.haveNextNextGaussian, Pit.java.util.Random.!java.util.Random.seed, Pit.java.util.Random.!java.util.concurrent.atomic.AtomicLong.value } U = { Pit.!Pit( GameInfo ).height, Pit.!Pit( GameInfo ).width, Pit.columns, Pit.java.util.Random.!java.util.Random.seed, Pit.rows, Tile.SIZE, i$0.font, i$0.height, i$0.level, i$0.lines, i$0.offImage, i$0.offg, i$0.score, i$0.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.!java.lang.Runtime.currentRuntime }
  10 localDeclaration D = { cp$0 } U = { this.!getContentPane( ) }
  11 receiver D = {  } U = {  }
  12 methodCall D = {  } U = { this.!javax.swing.JFrame.rootPane, this.!javax.swing.JRootPane.contentPane } TO = javax.swing.JFrame#getContentPane( )
  13 actualOut D = { this.!getContentPane( ) } U = { this.!javax.swing.JFrame.rootPane, this.!javax.swing.JRootPane.contentPane }
  14 assignment D = {  } U = { cp$0.!setLayout( java.awt.LayoutManager ) }
  15 receiver D = {  } U = { cp$0 }
  16 methodCall D = {  } U = { java.awt.FlowLayout.!FlowLayout( int ) } TO = java.awt.Container#setLayout( java.awt.LayoutManager )
  17 receiver D = {  } U = {  }
  18 constructorCall D = {  } U = { FlowLayout.CENTER } TO = java.awt.FlowLayout#FlowLayout( int )
* actualOut D = { java.awt.FlowLayout.!FlowLayout( int ), java.awt.FlowLayout.!java.awt.FlowLayout.hgap, java.awt.FlowLayout.!java.awt.FlowLayout.serialVersionOnStream, java.awt.FlowLayout.!java.awt.FlowLayout.vgap } U = {  }
* actualOut D = { cp$0.!java.awt.Container.layoutMgr, cp$0.!setLayout( java.awt.LayoutManager ) } U = {  }
  21 assignment D = {  } U = { cp$0.!add( java.awt.Component ) }
  22 receiver D = {  } U = { cp$0 }
  23 methodCall D = {  } U = { Pit.!Pit( GameInfo ).box, Pit.!Pit( GameInfo ).currentBlock, Pit.!Pit( GameInfo ).font, Pit.!Pit( GameInfo ).height, Pit.!Pit( GameInfo ).info, Pit.!Pit( GameInfo ).nextBlock, Pit.!Pit( GameInfo ).offImage, Pit.!Pit( GameInfo ).offg, Pit.!Pit( GameInfo ).rnd, Pit.!Pit( GameInfo ).width, cp$0.!java.awt.Component.parent, cp$0.!java.awt.Container.component, cp$0.!java.awt.Container.containerListener, cp$0.!java.awt.Container.eventMask, cp$0.!java.awt.Container.layoutMgr, cp$0.!java.awt.Container.peer, this.!getContentPane( ).!java.awt.Component.parent, this.!getContentPane( ).!java.awt.Container.component, this.!getContentPane( ).!java.awt.Container.containerListener, this.!getContentPane( ).!java.awt.Container.eventMask, this.!getContentPane( ).!java.awt.Container.layoutMgr, this.!getContentPane( ).!java.awt.Container.peer, this.pit, this.pit.box, this.pit.currentBlock, this.pit.font, this.pit.height, this.pit.info, this.pit.nextBlock, this.pit.offImage, this.pit.offg, this.pit.rnd, this.pit.width } TO = java.awt.Container#add( java.awt.Component )
* actualOut D = { cp$0.!add( java.awt.Component ), cp$0.!java.awt.Component.parent } U = { cp$0.!java.awt.Component.parent, cp$0.!java.awt.Container.component, cp$0.!java.awt.Container.containerListener, cp$0.!java.awt.Container.eventMask, cp$0.!java.awt.Container.layoutMgr, cp$0.!java.awt.Container.peer, this.!getContentPane( ).!java.awt.Component.parent, this.!getContentPane( ).!java.awt.Container.component, this.!getContentPane( ).!java.awt.Container.containerListener, this.!getContentPane( ).!java.awt.Container.eventMask, this.!getContentPane( ).!java.awt.Container.layoutMgr, this.!getContentPane( ).!java.awt.Container.peer }
  25 assignment D = {  } U = { cp$0.!add( java.awt.Component ) }
  26 receiver D = {  } U = { cp$0 }
  27 methodCall D = {  } U = { GameInfo.!GameInfo( ).font, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).level, GameInfo.!GameInfo( ).lines, GameInfo.!GameInfo( ).offImage, GameInfo.!GameInfo( ).offg, GameInfo.!GameInfo( ).score, GameInfo.!GameInfo( ).width, cp$0.!java.awt.Component.parent, cp$0.!java.awt.Container.component, cp$0.!java.awt.Container.containerListener, cp$0.!java.awt.Container.eventMask, cp$0.!java.awt.Container.layoutMgr, cp$0.!java.awt.Container.peer, this.!getContentPane( ).!java.awt.Component.parent, this.!getContentPane( ).!java.awt.Container.component, this.!getContentPane( ).!java.awt.Container.containerListener, this.!getContentPane( ).!java.awt.Container.eventMask, this.!getContentPane( ).!java.awt.Container.layoutMgr, this.!getContentPane( ).!java.awt.Container.peer, this.info, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.offImage, this.info.offg, this.info.score, this.info.width } TO = java.awt.Container#add( java.awt.Component )
* actualOut D = { cp$0.!add( java.awt.Component ), cp$0.!java.awt.Component.parent } U = { cp$0.!java.awt.Component.parent, cp$0.!java.awt.Container.component, cp$0.!java.awt.Container.containerListener, cp$0.!java.awt.Container.eventMask, cp$0.!java.awt.Container.layoutMgr, cp$0.!java.awt.Container.peer, this.!getContentPane( ).!java.awt.Component.parent, this.!getContentPane( ).!java.awt.Container.component, this.!getContentPane( ).!java.awt.Container.containerListener, this.!getContentPane( ).!java.awt.Container.eventMask, this.!getContentPane( ).!java.awt.Container.layoutMgr, this.!getContentPane( ).!java.awt.Container.peer }
  29 assignment D = {  } U = { this.!pack( ) }
  30 receiver D = {  } U = {  }
  31 methodCall D = {  } U = { this.!java.awt.Container.component, this.!java.awt.Container.peer, this.!java.awt.Dimension.height, this.!java.awt.Dimension.width, this.!java.awt.Window.allWindows, this.!java.awt.Window.beforeFirstShow, this.!java.awt.Window.parent, this.!java.awt.Window.peer, this.!java.awt.Window.x, this.!java.awt.Window.y } TO = java.awt.Window#pack( )
* actualOut D = { this.!java.awt.Container.descendUnconditionallyWhenValidating, this.!java.awt.Container.dispatcher, this.!java.awt.Window.isPacked, this.!java.awt.Window.peer, this.!pack( ) } U = { this.!java.awt.Container.component, this.!java.awt.Container.peer, this.!java.awt.Dimension.height, this.!java.awt.Dimension.width, this.!java.awt.Window.allWindows, this.!java.awt.Window.beforeFirstShow, this.!java.awt.Window.parent, this.!java.awt.Window.peer, this.!java.awt.Window.x, this.!java.awt.Window.y }
  33 assignment D = {  } U = { this.!setVisible( boolean ) }
  34 receiver D = {  } U = {  }
  35 methodCall D = {  } U = {  } TO = java.awt.Window#setVisible( boolean )
  36 actualOut D = { this.!setVisible( boolean ) } U = {  }
  37 assignment D = {  } U = { this.pit.!init( ) }
  38 receiver D = {  } U = { this.pit }
  39 methodCall D = {  } U = { Color.white, Font.BOLD, Pit.!Pit( GameInfo ).height, Pit.!Pit( GameInfo ).offImage, Pit.!Pit( GameInfo ).offg, Pit.!Pit( GameInfo ).width, Pit.backgroundColor, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.font, this.offg, this.pit.height, this.pit.offImage, this.pit.offg, this.pit.width } TO = Pit#init( )
* actualOut D = { this.pit.!init( ), this.pit.java.awt.Font.!java.awt.Font.createdFont, this.pit.java.awt.Font.!java.awt.Font.fontSerializedDataVersion, this.pit.java.awt.Font.!java.awt.Font.name, this.pit.java.awt.Font.!java.awt.Font.pointSize, this.pit.java.awt.Font.!java.awt.Font.size, this.pit.java.awt.Font.!java.awt.Font.style } U = { Color.white, Font.BOLD, Pit.!Pit( GameInfo ).height, Pit.!Pit( GameInfo ).offImage, Pit.!Pit( GameInfo ).offg, Pit.!Pit( GameInfo ).width, Pit.backgroundColor, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.font, this.offg, this.pit.height, this.pit.offImage, this.pit.offg, this.pit.width }
  41 assignment D = {  } U = { this.info.!init( ) }
  42 receiver D = {  } U = { this.info }
  43 methodCall D = {  } U = { Font.BOLD, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).offImage, GameInfo.!GameInfo( ).width, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.info.height, this.info.offImage, this.info.width } TO = GameInfo#init( )
* actualOut D = { this.info.!init( ), this.info.java.awt.Font.!java.awt.Font.createdFont, this.info.java.awt.Font.!java.awt.Font.fontSerializedDataVersion, this.info.java.awt.Font.!java.awt.Font.name, this.info.java.awt.Font.!java.awt.Font.pointSize, this.info.java.awt.Font.!java.awt.Font.size, this.info.java.awt.Font.!java.awt.Font.style } U = { Font.BOLD, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).offImage, GameInfo.!GameInfo( ).width, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.info.height, this.info.offImage, this.info.width }
  45 assignment D = {  } U = { this.pit.!placeNextBlock( ) }
  46 receiver D = {  } U = { this.pit }
  47 methodCall D = {  } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.!Pit( GameInfo ).box, Pit.!Pit( GameInfo ).currentBlock, Pit.!Pit( GameInfo ).currentBlock.tile$3.posX, Pit.!Pit( GameInfo ).currentBlock.tile$3.posY, Pit.!Pit( GameInfo ).currentBlock.tiles, Pit.!Pit( GameInfo ).currentBlock.tiles.!java.util.HashMap.keySet, Pit.!Pit( GameInfo ).currentBlock.tiles.!java.util.HashSet.map, Pit.!Pit( GameInfo ).nextBlock, Pit.!Pit( GameInfo ).rnd, Pit.!Pit( GameInfo ).rnd.!java.util.Random.seed, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Pit#placeNextBlock( )
* actualOut D = { this.pit.!placeNextBlock( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.!Pit( GameInfo ).box, Pit.!Pit( GameInfo ).currentBlock, Pit.!Pit( GameInfo ).currentBlock.tile$3.posX, Pit.!Pit( GameInfo ).currentBlock.tile$3.posY, Pit.!Pit( GameInfo ).currentBlock.tiles, Pit.!Pit( GameInfo ).currentBlock.tiles.!java.util.HashMap.keySet, Pit.!Pit( GameInfo ).currentBlock.tiles.!java.util.HashSet.map, Pit.!Pit( GameInfo ).nextBlock, Pit.!Pit( GameInfo ).rnd, Pit.!Pit( GameInfo ).rnd.!java.util.Random.seed, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  49 assignment D = {  } U = { this.info.!update( Block ) }
  50 receiver D = {  } U = { this.info }
  51 methodCall D = {  } U = { Color.black, Color.gray, Color.white, GameInfo.!GameInfo( ).font, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).level, GameInfo.!GameInfo( ).lines, GameInfo.!GameInfo( ).nextBlock$0.offsetX, GameInfo.!GameInfo( ).nextBlock$0.offsetY, GameInfo.!GameInfo( ).nextBlock$0.tile$2.color, GameInfo.!GameInfo( ).nextBlock$0.tile$2.posX, GameInfo.!GameInfo( ).nextBlock$0.tile$2.posY, GameInfo.!GameInfo( ).nextBlock$0.tiles, GameInfo.!GameInfo( ).nextBlock$0.tiles.!java.util.HashMap.keySet, GameInfo.!GameInfo( ).nextBlock$0.tiles.!java.util.HashSet.map, GameInfo.!GameInfo( ).offg, GameInfo.!GameInfo( ).score, GameInfo.!GameInfo( ).width, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width } TO = GameInfo#update( Block )
  52 actualIn D = {  } U = { this.pit.!getNextBlock( ) }
  53 receiver D = {  } U = { this.pit }
  54 methodCall D = {  } U = { Pit.!Pit( GameInfo ).nextBlock, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock } TO = Pit#getNextBlock( )
  55 actualOut D = { this.pit.!getNextBlock( ) } U = { Pit.!Pit( GameInfo ).nextBlock, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock }
* actualOut D = { this.info.!update( Block ), this.info.nextBlock$0.tile$2.color.!java.awt.Color.cs, this.info.nextBlock$0.tile$2.color.!java.awt.Color.falpha, this.info.nextBlock$0.tile$2.color.!java.awt.Color.frgbvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.fvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.value, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.gray, Color.white, GameInfo.!GameInfo( ).font, GameInfo.!GameInfo( ).height, GameInfo.!GameInfo( ).level, GameInfo.!GameInfo( ).lines, GameInfo.!GameInfo( ).nextBlock$0.offsetX, GameInfo.!GameInfo( ).nextBlock$0.offsetY, GameInfo.!GameInfo( ).nextBlock$0.tile$2.color, GameInfo.!GameInfo( ).nextBlock$0.tile$2.posX, GameInfo.!GameInfo( ).nextBlock$0.tile$2.posY, GameInfo.!GameInfo( ).nextBlock$0.tiles, GameInfo.!GameInfo( ).nextBlock$0.tiles.!java.util.HashMap.keySet, GameInfo.!GameInfo( ).nextBlock$0.tiles.!java.util.HashSet.map, GameInfo.!GameInfo( ).offg, GameInfo.!GameInfo( ).score, GameInfo.!GameInfo( ).width, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width }
  57 assignment D = {  } U = { this.pit.!addKeyListener( java.awt.event.KeyListener ) }
  58 receiver D = {  } U = { this.pit }
  59 methodCall D = {  } U = { Pit.!Pit( GameInfo ).!java.awt.Component.keyListener, Pit.!Pit( GameInfo ).!java.awt.Component.parent, Pit.!Pit( GameInfo ).!java.awt.Component.peer, Pit.!Pit( GameInfo ).!java.awt.Container.dispatcher, Pit.!Pit( GameInfo ).!java.awt.Container.parent, Pit.!Pit( GameInfo ).!java.awt.Container.peer, this, this.pit.!java.awt.Component.keyListener, this.pit.!java.awt.Component.parent, this.pit.!java.awt.Component.peer, this.pit.!java.awt.Container.dispatcher, this.pit.!java.awt.Container.parent, this.pit.!java.awt.Container.peer } TO = java.awt.Component#addKeyListener( java.awt.event.KeyListener )
* actualOut D = { this.pit.!addKeyListener( java.awt.event.KeyListener ), this.pit.!java.awt.Component.keyListener, this.pit.!java.awt.Component.newEventsOnly } U = { Pit.!Pit( GameInfo ).!java.awt.Component.keyListener, Pit.!Pit( GameInfo ).!java.awt.Component.parent, Pit.!Pit( GameInfo ).!java.awt.Component.peer, Pit.!Pit( GameInfo ).!java.awt.Container.dispatcher, Pit.!Pit( GameInfo ).!java.awt.Container.parent, Pit.!Pit( GameInfo ).!java.awt.Container.peer, this.pit.!java.awt.Component.keyListener, this.pit.!java.awt.Component.parent, this.pit.!java.awt.Component.peer, this.pit.!java.awt.Container.dispatcher, this.pit.!java.awt.Container.parent, this.pit.!java.awt.Container.peer }
  61 assignment D = {  } U = { this.info.!addKeyListener( java.awt.event.KeyListener ) }
  62 receiver D = {  } U = { this.info }
  63 methodCall D = {  } U = { GameInfo.!GameInfo( ).!java.awt.Component.keyListener, GameInfo.!GameInfo( ).!java.awt.Component.parent, GameInfo.!GameInfo( ).!java.awt.Component.peer, GameInfo.!GameInfo( ).!java.awt.Container.dispatcher, GameInfo.!GameInfo( ).!java.awt.Container.parent, GameInfo.!GameInfo( ).!java.awt.Container.peer, this, this.info.!java.awt.Component.keyListener, this.info.!java.awt.Component.parent, this.info.!java.awt.Component.peer, this.info.!java.awt.Container.dispatcher, this.info.!java.awt.Container.parent, this.info.!java.awt.Container.peer } TO = java.awt.Component#addKeyListener( java.awt.event.KeyListener )
* actualOut D = { this.info.!addKeyListener( java.awt.event.KeyListener ), this.info.!java.awt.Component.keyListener, this.info.!java.awt.Component.newEventsOnly } U = { GameInfo.!GameInfo( ).!java.awt.Component.keyListener, GameInfo.!GameInfo( ).!java.awt.Component.parent, GameInfo.!GameInfo( ).!java.awt.Component.peer, GameInfo.!GameInfo( ).!java.awt.Container.dispatcher, GameInfo.!GameInfo( ).!java.awt.Container.parent, GameInfo.!GameInfo( ).!java.awt.Container.peer, this.info.!java.awt.Component.keyListener, this.info.!java.awt.Component.parent, this.info.!java.awt.Component.peer, this.info.!java.awt.Container.dispatcher, this.info.!java.awt.Container.parent, this.info.!java.awt.Container.peer }
  65 assignment D = {  } U = { this.!requestFocus( ) }
  66 receiver D = {  } U = {  }
  67 methodCall D = {  } U = { this.!java.awt.event.FocusEvent$Cause.UNKNOWN } TO = java.awt.Component#requestFocus( )
  68 actualOut D = { this.!requestFocus( ) } U = { this.!java.awt.event.FocusEvent$Cause.UNKNOWN }
  69 methodExit
  70 formalOut D = {  } U = { $_ }
* actualOut D = { GameInfo.!GameInfo( ).height } U = {  }
* actualOut D = { GameInfo.!GameInfo( ).width } U = {  }
* actualOut D = { Pit.!Pit( GameInfo ).box } U = {  }
* actualOut D = { Pit.!Pit( GameInfo ).height } U = {  }
* actualOut D = { Pit.!Pit( GameInfo ).info } U = {  }
* actualOut D = { Pit.!Pit( GameInfo ).rnd } U = {  }
* actualOut D = { Pit.!Pit( GameInfo ).width } U = {  }
* actualOut D = { this.pit.font } U = {  }
* actualOut D = { this.pit.offImage } U = {  }
* actualOut D = { this.pit.offg } U = {  }
* actualOut D = { this.info.font } U = {  }
* actualOut D = { this.info.offImage } U = {  }
* actualOut D = { this.info.offg } U = {  }
* actualOut D = { this.offsetX } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.pit.nextBlock.pit } U = {  }
* actualOut D = { super.posX } U = {  }
* actualOut D = { this.pit.currentBlock.posX } U = {  }
* actualOut D = { super.posY } U = {  }
* actualOut D = { this.pit.currentBlock.posY } U = {  }
* actualOut D = { this.pit.currentBlock } U = {  }
* actualOut D = { this.pit.nextBlock } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).color } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posX } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posX } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posY } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posY } U = {  }
--
   0 methodEntry [ Tetris#keyTyped( java.awt.event.KeyEvent ) ]
   1 formalIn D = { e$0 } U = {  }
   2 methodExit
   3 formalOut D = {  } U = { $_ }
--
   0 methodEntry [ Tetris#main( java.lang.String[] ) ]
   1 formalIn D = { argv$0 } U = {  }
   2 localDeclaration D = { tetris$1 } U = { Tetris.!Tetris( ) }
   3 receiver D = {  } U = {  }
   4 constructorCall D = {  } U = {  } TO = Tetris#Tetris( )
   5 actualOut D = { Tetris.!Tetris( ) } U = {  }
   6 assignment D = {  } U = { tetris$1.!init( ) }
   7 receiver D = {  } U = { tetris$1 }
   8 methodCall D = {  } U = { Block.NUMBER_OF, BlueBlock.COLOR, Color.black, Color.gray, Color.white, CyanBlock.COLOR, FlowLayout.CENTER, Font.BOLD, GameInfo.rows, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.backgroundColor, Pit.columns, Pit.initPosX, Pit.initPosY, Pit.rows, RedBlock.color, Tetris.!Tetris( ).!init( ).height, Tetris.!Tetris( ).!init( ).width, Tetris.!Tetris( ).Pit.java.util.Random.!java.util.Random.seed, Tetris.!Tetris( ).cp$0.!java.awt.Component.parent, Tetris.!Tetris( ).cp$0.!java.awt.Container.component, Tetris.!Tetris( ).cp$0.!java.awt.Container.containerListener, Tetris.!Tetris( ).cp$0.!java.awt.Container.eventMask, Tetris.!Tetris( ).cp$0.!java.awt.Container.layoutMgr, Tetris.!Tetris( ).cp$0.!java.awt.Container.peer, Tetris.!Tetris( ).info, Tetris.!Tetris( ).info.!java.awt.Component.keyListener, Tetris.!Tetris( ).info.!java.awt.Component.parent, Tetris.!Tetris( ).info.!java.awt.Component.peer, Tetris.!Tetris( ).info.font, Tetris.!Tetris( ).info.height, Tetris.!Tetris( ).info.level, Tetris.!Tetris( ).info.lines, Tetris.!Tetris( ).info.nextBlock$0.offsetX, Tetris.!Tetris( ).info.nextBlock$0.offsetY, Tetris.!Tetris( ).info.nextBlock$0.tile$2.color, Tetris.!Tetris( ).info.nextBlock$0.tile$2.posX, Tetris.!Tetris( ).info.nextBlock$0.tile$2.posY, Tetris.!Tetris( ).info.nextBlock$0.tiles, Tetris.!Tetris( ).info.nextBlock$0.tiles.!java.util.HashSet.map, Tetris.!Tetris( ).info.offImage, Tetris.!Tetris( ).info.offg, Tetris.!Tetris( ).info.score, Tetris.!Tetris( ).info.width, Tetris.!Tetris( ).pit, Tetris.!Tetris( ).pit.!java.awt.Component.keyListener, Tetris.!Tetris( ).pit.!java.awt.Component.parent, Tetris.!Tetris( ).pit.!java.awt.Component.peer, Tetris.!Tetris( ).pit.!java.awt.Container.dispatcher, Tetris.!Tetris( ).pit.!java.awt.Container.parent, Tetris.!Tetris( ).pit.!java.awt.Container.peer, Tetris.!Tetris( ).pit.currentBlock, Tetris.!Tetris( ).pit.currentBlock.tile$3.posX, Tetris.!Tetris( ).pit.currentBlock.tile$3.posY, Tetris.!Tetris( ).pit.currentBlock.tiles, Tetris.!Tetris( ).pit.currentBlock.tiles.!java.util.HashMap.keySet, Tetris.!Tetris( ).pit.currentBlock.tiles.!java.util.HashSet.map, Tetris.!Tetris( ).pit.height, Tetris.!Tetris( ).pit.nextBlock, Tetris.!Tetris( ).pit.offImage, Tetris.!Tetris( ).pit.offg, Tetris.!Tetris( ).pit.rnd, Tetris.!Tetris( ).pit.rnd.!java.util.Random.seed, Tetris.!Tetris( ).pit.width, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, YellowBlock.COLOR, i$0.font, i$0.height, i$0.level, i$0.lines, i$0.offImage, i$0.offg, i$0.score, i$0.width, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, tetris$1.!init( ).height, tetris$1.!init( ).width, tetris$1.Pit.java.util.Random.!java.util.Random.seed, tetris$1.cp$0.!java.awt.Component.parent, tetris$1.cp$0.!java.awt.Container.component, tetris$1.cp$0.!java.awt.Container.containerListener, tetris$1.cp$0.!java.awt.Container.eventMask, tetris$1.cp$0.!java.awt.Container.layoutMgr, tetris$1.cp$0.!java.awt.Container.peer, tetris$1.info, tetris$1.info.!java.awt.Component.keyListener, tetris$1.info.!java.awt.Component.parent, tetris$1.info.!java.awt.Component.peer, tetris$1.info.font, tetris$1.info.height, tetris$1.info.level, tetris$1.info.lines, tetris$1.info.nextBlock$0.offsetX, tetris$1.info.nextBlock$0.offsetY, tetris$1.info.nextBlock$0.tile$2.color, tetris$1.info.nextBlock$0.tile$2.posX, tetris$1.info.nextBlock$0.tile$2.posY, tetris$1.info.nextBlock$0.tiles, tetris$1.info.nextBlock$0.tiles.!java.util.HashSet.map, tetris$1.info.offImage, tetris$1.info.offg, tetris$1.info.score, tetris$1.info.width, tetris$1.pit, tetris$1.pit.!java.awt.Component.keyListener, tetris$1.pit.!java.awt.Component.parent, tetris$1.pit.!java.awt.Component.peer, tetris$1.pit.!java.awt.Container.dispatcher, tetris$1.pit.!java.awt.Container.parent, tetris$1.pit.!java.awt.Container.peer, tetris$1.pit.currentBlock, tetris$1.pit.currentBlock.tile$3.posX, tetris$1.pit.currentBlock.tile$3.posY, tetris$1.pit.currentBlock.tiles, tetris$1.pit.currentBlock.tiles.!java.util.HashMap.keySet, tetris$1.pit.currentBlock.tiles.!java.util.HashSet.map, tetris$1.pit.height, tetris$1.pit.nextBlock, tetris$1.pit.offImage, tetris$1.pit.offg, tetris$1.pit.rnd, tetris$1.pit.rnd.!java.util.Random.seed, tetris$1.pit.width, this, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.!java.awt.Container.component, this.!java.awt.Container.peer, this.!java.awt.Dimension.height, this.!java.awt.Dimension.width, this.!java.awt.Window.allWindows, this.!java.awt.Window.beforeFirstShow, this.!java.awt.Window.parent, this.!java.awt.Window.peer, this.!java.awt.Window.x, this.!java.awt.Window.y, this.!java.awt.event.FocusEvent$Cause.UNKNOWN, this.!java.lang.Runtime.currentRuntime, this.!javax.swing.JFrame.rootPane, this.!javax.swing.JRootPane.contentPane, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.font, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.offImage, this.info.offg, this.info.score, this.info.width, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offg, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.font, this.pit.height, this.pit.info, this.pit.nextBlock, this.pit.offImage, this.pit.offg, this.pit.rnd, this.pit.width, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Tetris#init( )
* actualOut D = { tetris$1.!init( ), tetris$1.Pit.java.util.Random.!java.util.Random.haveNextNextGaussian, tetris$1.Pit.java.util.Random.!java.util.Random.seed, tetris$1.Pit.java.util.Random.!java.util.concurrent.atomic.AtomicLong.value, tetris$1.cp$0.!java.awt.Component.parent, tetris$1.cp$0.!java.awt.Container.layoutMgr, tetris$1.info.!java.awt.Component.keyListener, tetris$1.info.!java.awt.Component.newEventsOnly, tetris$1.info.java.awt.Font.!java.awt.Font.createdFont, tetris$1.info.java.awt.Font.!java.awt.Font.fontSerializedDataVersion, tetris$1.info.java.awt.Font.!java.awt.Font.name, tetris$1.info.java.awt.Font.!java.awt.Font.pointSize, tetris$1.info.java.awt.Font.!java.awt.Font.size, tetris$1.info.java.awt.Font.!java.awt.Font.style, tetris$1.info.nextBlock$0.tile$2.color.!java.awt.Color.cs, tetris$1.info.nextBlock$0.tile$2.color.!java.awt.Color.falpha, tetris$1.info.nextBlock$0.tile$2.color.!java.awt.Color.frgbvalue, tetris$1.info.nextBlock$0.tile$2.color.!java.awt.Color.fvalue, tetris$1.info.nextBlock$0.tile$2.color.!java.awt.Color.value, tetris$1.java.awt.FlowLayout.!java.awt.FlowLayout.hgap, tetris$1.java.awt.FlowLayout.!java.awt.FlowLayout.serialVersionOnStream, tetris$1.java.awt.FlowLayout.!java.awt.FlowLayout.vgap, tetris$1.pit.!java.awt.Component.keyListener, tetris$1.pit.!java.awt.Component.newEventsOnly, tetris$1.pit.currentBlock.tiles.!java.util.HashMap.keySet, tetris$1.pit.java.awt.Font.!java.awt.Font.createdFont, tetris$1.pit.java.awt.Font.!java.awt.Font.fontSerializedDataVersion, tetris$1.pit.java.awt.Font.!java.awt.Font.name, tetris$1.pit.java.awt.Font.!java.awt.Font.pointSize, tetris$1.pit.java.awt.Font.!java.awt.Font.size, tetris$1.pit.java.awt.Font.!java.awt.Font.style, this.!java.awt.Container.descendUnconditionallyWhenValidating, this.!java.awt.Container.dispatcher, this.!java.awt.Window.isPacked, this.!java.awt.Window.peer } U = { Block.NUMBER_OF, BlueBlock.COLOR, Color.black, Color.gray, Color.white, CyanBlock.COLOR, FlowLayout.CENTER, Font.BOLD, GameInfo.rows, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.backgroundColor, Pit.columns, Pit.initPosX, Pit.initPosY, Pit.rows, RedBlock.color, Tetris.!Tetris( ).!init( ).height, Tetris.!Tetris( ).!init( ).width, Tetris.!Tetris( ).Pit.java.util.Random.!java.util.Random.seed, Tetris.!Tetris( ).cp$0.!java.awt.Component.parent, Tetris.!Tetris( ).cp$0.!java.awt.Container.component, Tetris.!Tetris( ).cp$0.!java.awt.Container.containerListener, Tetris.!Tetris( ).cp$0.!java.awt.Container.eventMask, Tetris.!Tetris( ).cp$0.!java.awt.Container.layoutMgr, Tetris.!Tetris( ).cp$0.!java.awt.Container.peer, Tetris.!Tetris( ).info, Tetris.!Tetris( ).info.!java.awt.Component.keyListener, Tetris.!Tetris( ).info.!java.awt.Component.parent, Tetris.!Tetris( ).info.!java.awt.Component.peer, Tetris.!Tetris( ).info.font, Tetris.!Tetris( ).info.height, Tetris.!Tetris( ).info.level, Tetris.!Tetris( ).info.lines, Tetris.!Tetris( ).info.nextBlock$0.offsetX, Tetris.!Tetris( ).info.nextBlock$0.offsetY, Tetris.!Tetris( ).info.nextBlock$0.tile$2.color, Tetris.!Tetris( ).info.nextBlock$0.tile$2.posX, Tetris.!Tetris( ).info.nextBlock$0.tile$2.posY, Tetris.!Tetris( ).info.nextBlock$0.tiles, Tetris.!Tetris( ).info.nextBlock$0.tiles.!java.util.HashSet.map, Tetris.!Tetris( ).info.offImage, Tetris.!Tetris( ).info.offg, Tetris.!Tetris( ).info.score, Tetris.!Tetris( ).info.width, Tetris.!Tetris( ).pit, Tetris.!Tetris( ).pit.!java.awt.Component.keyListener, Tetris.!Tetris( ).pit.!java.awt.Component.parent, Tetris.!Tetris( ).pit.!java.awt.Component.peer, Tetris.!Tetris( ).pit.!java.awt.Container.dispatcher, Tetris.!Tetris( ).pit.!java.awt.Container.parent, Tetris.!Tetris( ).pit.!java.awt.Container.peer, Tetris.!Tetris( ).pit.currentBlock, Tetris.!Tetris( ).pit.currentBlock.tile$3.posX, Tetris.!Tetris( ).pit.currentBlock.tile$3.posY, Tetris.!Tetris( ).pit.currentBlock.tiles, Tetris.!Tetris( ).pit.currentBlock.tiles.!java.util.HashMap.keySet, Tetris.!Tetris( ).pit.currentBlock.tiles.!java.util.HashSet.map, Tetris.!Tetris( ).pit.height, Tetris.!Tetris( ).pit.nextBlock, Tetris.!Tetris( ).pit.offImage, Tetris.!Tetris( ).pit.offg, Tetris.!Tetris( ).pit.rnd, Tetris.!Tetris( ).pit.rnd.!java.util.Random.seed, Tetris.!Tetris( ).pit.width, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, YellowBlock.COLOR, i$0.font, i$0.height, i$0.level, i$0.lines, i$0.offImage, i$0.offg, i$0.score, i$0.width, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, tetris$1.!init( ).height, tetris$1.!init( ).width, tetris$1.Pit.java.util.Random.!java.util.Random.seed, tetris$1.cp$0.!java.awt.Component.parent, tetris$1.cp$0.!java.awt.Container.component, tetris$1.cp$0.!java.awt.Container.containerListener, tetris$1.cp$0.!java.awt.Container.eventMask, tetris$1.cp$0.!java.awt.Container.layoutMgr, tetris$1.cp$0.!java.awt.Container.peer, tetris$1.info, tetris$1.info.!java.awt.Component.keyListener, tetris$1.info.!java.awt.Component.parent, tetris$1.info.!java.awt.Component.peer, tetris$1.info.font, tetris$1.info.height, tetris$1.info.level, tetris$1.info.lines, tetris$1.info.nextBlock$0.offsetX, tetris$1.info.nextBlock$0.offsetY, tetris$1.info.nextBlock$0.tile$2.color, tetris$1.info.nextBlock$0.tile$2.posX, tetris$1.info.nextBlock$0.tile$2.posY, tetris$1.info.nextBlock$0.tiles, tetris$1.info.nextBlock$0.tiles.!java.util.HashSet.map, tetris$1.info.offImage, tetris$1.info.offg, tetris$1.info.score, tetris$1.info.width, tetris$1.pit, tetris$1.pit.!java.awt.Component.keyListener, tetris$1.pit.!java.awt.Component.parent, tetris$1.pit.!java.awt.Component.peer, tetris$1.pit.!java.awt.Container.dispatcher, tetris$1.pit.!java.awt.Container.parent, tetris$1.pit.!java.awt.Container.peer, tetris$1.pit.currentBlock, tetris$1.pit.currentBlock.tile$3.posX, tetris$1.pit.currentBlock.tile$3.posY, tetris$1.pit.currentBlock.tiles, tetris$1.pit.currentBlock.tiles.!java.util.HashMap.keySet, tetris$1.pit.currentBlock.tiles.!java.util.HashSet.map, tetris$1.pit.height, tetris$1.pit.nextBlock, tetris$1.pit.offImage, tetris$1.pit.offg, tetris$1.pit.rnd, tetris$1.pit.rnd.!java.util.Random.seed, tetris$1.pit.width, this, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.!java.awt.Container.component, this.!java.awt.Container.peer, this.!java.awt.Dimension.height, this.!java.awt.Dimension.width, this.!java.awt.Window.allWindows, this.!java.awt.Window.beforeFirstShow, this.!java.awt.Window.parent, this.!java.awt.Window.peer, this.!java.awt.Window.x, this.!java.awt.Window.y, this.!java.awt.event.FocusEvent$Cause.UNKNOWN, this.!java.lang.Runtime.currentRuntime, this.!javax.swing.JFrame.rootPane, this.!javax.swing.JRootPane.contentPane, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.font, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.offImage, this.info.offg, this.info.score, this.info.width, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offg, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.font, this.pit.height, this.pit.info, this.pit.nextBlock, this.pit.offImage, this.pit.offg, this.pit.rnd, this.pit.width, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  10 methodExit
  11 formalOut D = {  } U = { $_ }
* actualOut D = { this.offsetX } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { tetris$1.pit.nextBlock.pit } U = {  }
* actualOut D = { super.posX } U = {  }
* actualOut D = { tetris$1.pit.currentBlock.posX } U = {  }
* actualOut D = { super.posY } U = {  }
* actualOut D = { tetris$1.pit.currentBlock.posY } U = {  }
* actualOut D = { tetris$1.info.font } U = {  }
* actualOut D = { tetris$1.!init( ).height } U = {  }
* actualOut D = { tetris$1.info.offImage } U = {  }
* actualOut D = { tetris$1.info.offg } U = {  }
* actualOut D = { tetris$1.!init( ).width } U = {  }
* actualOut D = { tetris$1.!init( ).box } U = {  }
* actualOut D = { tetris$1.pit.currentBlock } U = {  }
* actualOut D = { tetris$1.pit.font } U = {  }
* actualOut D = { tetris$1.!init( ).height } U = {  }
* actualOut D = { tetris$1.!init( ).info } U = {  }
* actualOut D = { tetris$1.pit.nextBlock } U = {  }
* actualOut D = { tetris$1.pit.offImage } U = {  }
* actualOut D = { tetris$1.pit.offg } U = {  }
* actualOut D = { tetris$1.!init( ).rnd } U = {  }
* actualOut D = { tetris$1.!init( ).width } U = {  }
* actualOut D = { tetris$1.info } U = {  }
* actualOut D = { tetris$1.pit } U = {  }
* actualOut D = { tetris$1.pit.currentBlock.tile$3.posX } U = {  }
* actualOut D = { tetris$1.pit.currentBlock.tile$3.posY } U = {  }
--
   0 fieldEntry [ Tetris#COLUMNS ]
   1 fieldDeclaration D = { Tetris.COLUMNS } U = { Tetris.COLUMNS }
   2 fieldExit
--
   0 fieldEntry [ Tetris#ROWS ]
   1 fieldDeclaration D = { Tetris.ROWS } U = { Tetris.ROWS }
   2 fieldExit
--
   0 methodEntry [ Tetris#keyReleased( java.awt.event.KeyEvent ) ]
   1 formalIn D = { e$0 } U = {  }
   2 methodExit
   3 formalOut D = {  } U = { $_ }
--
   0 fieldEntry [ Tetris#pit ]
   1 fieldDeclaration D = { this.pit } U = { this.pit }
   2 fieldExit
--
   0 methodEntry [ Tetris#createTimer( ) ]
   1 ifSt D = {  } U = { this.timer }
   2 assignment D = {  } U = { this.!stopTimer( ) }
   3 receiver D = {  } U = {  }
   4 methodCall D = {  } U = {  } TO = Tetris#stopTimer( )
   5 actualOut D = { this.!stopTimer( ) } U = {  }
   6 merge ifSt(1)
   7 assignment D = { this.timer } U = { java.lang.Thread.!Thread( java.lang.Runnable ) }
   8 receiver D = {  } U = {  }
   9 constructorCall D = {  } U = { java.lang.Thread.!java.lang.StringBuilder.count, java.lang.Thread.!java.lang.StringBuilder.value, java.lang.Thread.!java.lang.Thread.threadInitNumber, this } TO = java.lang.Thread#Thread( java.lang.Runnable )
* actualOut D = { java.lang.Thread.!Thread( java.lang.Runnable ), java.lang.Thread.!java.lang.Thread.threadInitNumber } U = { java.lang.Thread.!java.lang.StringBuilder.count, java.lang.Thread.!java.lang.StringBuilder.value, java.lang.Thread.!java.lang.Thread.threadInitNumber }
  11 methodExit
  12 formalOut D = {  } U = { $_ }
* actualOut D = { this.timer } U = {  }
--
   0 fieldEntry [ Tetris#info ]
   1 fieldDeclaration D = { this.info } U = { this.info }
   2 fieldExit
--
   0 methodEntry [ Tetris#keyPressed( java.awt.event.KeyEvent ) ]
   1 formalIn D = { e$0 } U = {  }
   2 localDeclaration D = { keyCode$1 } U = { e$0.!getKeyCode( ) }
   3 receiver D = {  } U = { e$0 }
   4 methodCall D = {  } U = { e$0.!java.awt.event.KeyEvent.keyCode } TO = java.awt.event.KeyEvent#getKeyCode( )
   5 actualOut D = { e$0.!getKeyCode( ) } U = { e$0.!java.awt.event.KeyEvent.keyCode }
   6 ifSt D = {  } U = { keyCode$1, keyCode$1.VK_S }
   7 assignment D = {  } U = { this.!createTimer( ) }
   8 receiver D = {  } U = {  }
   9 methodCall D = {  } U = { this, this.java.lang.Thread.!java.lang.StringBuilder.count, this.java.lang.Thread.!java.lang.StringBuilder.value, this.java.lang.Thread.!java.lang.Thread.threadInitNumber, this.timer } TO = Tetris#createTimer( )
* actualOut D = { this.!createTimer( ), this.java.lang.Thread.!java.lang.Thread.threadInitNumber } U = { this, this.java.lang.Thread.!java.lang.StringBuilder.count, this.java.lang.Thread.!java.lang.StringBuilder.value, this.java.lang.Thread.!java.lang.Thread.threadInitNumber, this.timer }
  11 assignment D = {  } U = { this.pit.!gameStart( ) }
  12 receiver D = {  } U = { this.pit }
  13 methodCall D = {  } U = { Pit.columns, Pit.rows, t$2.color, t$2.posX, t$2.posY } TO = Pit#gameStart( )
  14 actualOut D = { this.pit.!gameStart( ) } U = { Pit.columns, Pit.rows, t$2.color, t$2.posX, t$2.posY }
  15 assignment D = {  } U = { this.info.!gameStart( ) }
  16 receiver D = {  } U = { this.info }
  17 methodCall D = {  } U = {  } TO = GameInfo#gameStart( )
  18 actualOut D = { this.info.!gameStart( ) } U = {  }
  19 assignment D = {  } U = { this.pit.!placeNextBlock( ) }
  20 receiver D = {  } U = { this.pit }
  21 methodCall D = {  } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Pit#placeNextBlock( )
* actualOut D = { this.pit.!placeNextBlock( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  23 assignment D = {  } U = { this.pit.!update( ) }
  24 receiver D = {  } U = { this.pit }
  25 methodCall D = {  } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY } TO = Pit#update( )
* actualOut D = { this.color.!java.awt.Color.cs, this.color.!java.awt.Color.falpha, this.color.!java.awt.Color.frgbvalue, this.color.!java.awt.Color.fvalue, this.color.!java.awt.Color.value, this.pit.!update( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY }
  27 assignment D = {  } U = { this.info.!update( Block ) }
  28 receiver D = {  } U = { this.info }
  29 methodCall D = {  } U = { Color.black, Color.gray, Color.white, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width } TO = GameInfo#update( Block )
  30 actualIn D = {  } U = { this.pit.!getNextBlock( ) }
  31 receiver D = {  } U = { this.pit }
  32 methodCall D = {  } U = { this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock } TO = Pit#getNextBlock( )
  33 actualOut D = { this.pit.!getNextBlock( ) } U = { this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock }
* actualOut D = { this.info.!update( Block ), this.info.nextBlock$0.tile$2.color.!java.awt.Color.cs, this.info.nextBlock$0.tile$2.color.!java.awt.Color.falpha, this.info.nextBlock$0.tile$2.color.!java.awt.Color.frgbvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.fvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.value, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.gray, Color.white, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width }
  35 assignment D = {  } U = { this.!startTimer( ) }
  36 receiver D = {  } U = {  }
  37 methodCall D = {  } U = { this.timer, this.timer.!java.lang.Thread.group, this.timer.!java.lang.Thread.threadStatus, this.timer.!java.lang.ThreadGroup.destroyed, this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads } TO = Tetris#startTimer( )
* actualOut D = { this.!startTimer( ), this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads } U = { this.timer, this.timer.!java.lang.Thread.group, this.timer.!java.lang.Thread.threadStatus, this.timer.!java.lang.ThreadGroup.destroyed, this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads }
  39 ifSt D = {  } U = { keyCode$1, keyCode$1.VK_Q }
  40 assignment D = {  } U = { this.!exit( int ) }
  41 receiver D = {  } U = {  }
  42 methodCall D = {  } U = { this.!java.lang.Runtime.currentRuntime } TO = java.lang.System#exit( int )
  43 actualOut D = { this.!exit( int ) } U = { this.!java.lang.Runtime.currentRuntime }
  44 merge ifSt(39)
  45 merge ifSt(6)
  46 ifSt D = {  } U = { this.timer }
  47 localDeclaration D = { block$2 } U = { this.pit.!getCurrentBlock( ) }
  48 receiver D = {  } U = { this.pit }
  49 methodCall D = {  } U = { this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock } TO = Pit#getCurrentBlock( )
  50 actualOut D = { this.pit.!getCurrentBlock( ) } U = { this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock }
  51 switchSt D = { $SwitchDef } U = { keyCode$1 }
  52 switchCase D = {  } U = { $SwitchDef, KeyEvent.VK_B }
  53 assignment D = {  } U = { block$2.!moveLeft( ) }
  54 receiver D = {  } U = { block$2 }
  55 methodCall D = {  } U = { block$2.posX, this.pit, this.pit.!getCurrentBlock( ).posX, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Block#moveLeft( )
* actualOut D = { block$2.!moveLeft( ), this.tiles.!java.util.HashMap.keySet } U = { block$2.posX, this.pit, this.pit.!getCurrentBlock( ).posX, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  57 breakSt D = {  } U = {  }
  58 switchCase D = {  } U = { $SwitchDef, KeyEvent.VK_M }
  59 assignment D = {  } U = { block$2.!moveRight( ) }
  60 receiver D = {  } U = { block$2 }
  61 methodCall D = {  } U = { block$2.posX, this.pit, this.pit.!getCurrentBlock( ).posX, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Block#moveRight( )
* actualOut D = { block$2.!moveRight( ), this.tiles.!java.util.HashMap.keySet } U = { block$2.posX, this.pit, this.pit.!getCurrentBlock( ).posX, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  63 breakSt D = {  } U = {  }
  64 switchCase D = {  } U = { $SwitchDef, KeyEvent.VK_N }
  65 assignment D = {  } U = { block$2.!rotate( ) }
  66 receiver D = {  } U = { block$2 }
  67 methodCall D = {  } U = { this.pit, this.pit.box, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, tile$1.color, tile$1.posX, tile$1.posY, x$0.COLUMNS, y$1.ROWS } TO = Block#rotate( )
* actualOut D = { block$2.!rotate( ), this.tiles.!java.util.HashMap.keySet } U = { this.pit, this.pit.box, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, tile$1.color, tile$1.posX, tile$1.posY, x$0.COLUMNS, y$1.ROWS }
  69 breakSt D = {  } U = {  }
  70 switchCase D = {  } U = { $SwitchDef, KeyEvent.VK_Z }
  71 assignment D = {  } U = { block$2.!drop( ) }
  72 receiver D = {  } U = { block$2 }
  73 methodCall D = {  } U = { block$2.posY, this.pit, this.pit.!getCurrentBlock( ).posY, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Block#drop( )
* actualOut D = { block$2.!drop( ), this.tiles.!java.util.HashMap.keySet } U = { block$2.posY, this.pit, this.pit.!getCurrentBlock( ).posY, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  75 breakSt D = {  } U = {  }
  76 merge switchSt(51)
  77 assignment D = {  } U = { this.pit.!update( ) }
  78 receiver D = {  } U = { this.pit }
  79 methodCall D = {  } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY } TO = Pit#update( )
* actualOut D = { this.color.!java.awt.Color.cs, this.color.!java.awt.Color.falpha, this.color.!java.awt.Color.frgbvalue, this.color.!java.awt.Color.fvalue, this.color.!java.awt.Color.value, this.pit.!update( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY }
  81 merge ifSt(46)
  82 methodExit
  83 formalOut D = {  } U = { $_ }
* actualOut D = { this.timer } U = {  }
* actualOut D = { this.timer } U = {  }
* actualOut D = { this.box } U = {  }
* actualOut D = { this.info.level } U = {  }
* actualOut D = { this.info.lines } U = {  }
* actualOut D = { this.info.score } U = {  }
* actualOut D = { this.offsetX } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.pit.nextBlock.pit } U = {  }
* actualOut D = { super.posX } U = {  }
* actualOut D = { this.pit.currentBlock.posX } U = {  }
* actualOut D = { super.posY } U = {  }
* actualOut D = { this.pit.currentBlock.posY } U = {  }
* actualOut D = { this.pit.currentBlock } U = {  }
* actualOut D = { this.pit.nextBlock } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).color } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posX } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posX } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posY } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posY } U = {  }
* actualOut D = { block$2.posX } U = {  }
* actualOut D = { this.tile$2.posX } U = {  }
* actualOut D = { block$2.posX } U = {  }
* actualOut D = { this.tile$2.posX } U = {  }
* actualOut D = { this.tile$1.posX } U = {  }
* actualOut D = { this.tile$1.posY } U = {  }
* actualOut D = { block$2.posY } U = {  }
* actualOut D = { this.tile$2.posY } U = {  }
--
   0 methodEntry [ Tetris#startTimer( ) ]
   1 assignment D = {  } U = { this.timer.!start( ) }
   2 receiver D = {  } U = { this.timer }
   3 methodCall D = {  } U = { this.timer.!java.lang.Thread.group, this.timer.!java.lang.Thread.threadStatus, this.timer.!java.lang.ThreadGroup.destroyed, this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads } TO = java.lang.Thread#start( )
* actualOut D = { this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads, this.timer.!start( ) } U = { this.timer.!java.lang.Thread.group, this.timer.!java.lang.Thread.threadStatus, this.timer.!java.lang.ThreadGroup.destroyed, this.timer.!java.lang.ThreadGroup.nUnstartedThreads, this.timer.!java.lang.ThreadGroup.nthreads, this.timer.!java.lang.ThreadGroup.threads }
   5 methodExit
   6 formalOut D = {  } U = { $_ }
--
   0 methodEntry [ Tetris#run( ) ]
   1 localDeclaration D = { isGameOver$0 } U = {  }
   2 localDeclaration D = { thisThread$1 } U = { this.!currentThread( ) }
   3 receiver D = {  } U = {  }
   4 methodCall D = {  } U = {  } TO = java.lang.Thread#currentThread( )
   5 actualOut D = { this.!currentThread( ) } U = {  }
   6 whileSt D = {  } U = { this.timer, thisThread$1 }
   7 trySt D = {  } U = {  }
   8 assignment D = {  } U = { this.!sleep( long ) }
   9 receiver D = {  } U = {  }
  10 methodCall D = {  } U = { this.info.!getSpeed( ) } TO = java.lang.Thread#sleep( long )
  11 receiver D = {  } U = { this.info }
  12 methodCall D = {  } U = { this.info.level } TO = GameInfo#getSpeed( )
  13 actualOut D = { this.info.!getSpeed( ) } U = { this.info.level }
  14 actualOut D = { this.!sleep( long ) } U = {  }
  15 merge trySt(7)
  16 catchClause D = { e$2 } U = {  }
  17 localDeclaration D = { block$3 } U = { this.pit.!getCurrentBlock( ) }
  18 receiver D = {  } U = { this.pit }
  19 methodCall D = {  } U = { this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock } TO = Pit#getCurrentBlock( )
  20 actualOut D = { this.pit.!getCurrentBlock( ) } U = { this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock }
  21 ifSt D = {  } U = { block$3.!fall( ) }
  22 receiver D = {  } U = { block$3 }
  23 methodCall D = {  } U = { block$3.posY, t$2.color, t$2.posX, t$2.posY, this.pit, this.pit.!getCurrentBlock( ).posY, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, tile$1.color, tile$1.posX, tile$1.posY, x$0.COLUMNS, y$1.ROWS } TO = Block#fall( )
* actualOut D = { block$3.!fall( ), this.tiles.!java.util.HashMap.keySet } U = { block$3.posY, t$2.color, t$2.posX, t$2.posY, this.pit, this.pit.!getCurrentBlock( ).posY, this.pit.box, this.tile$3.posX, this.tile$3.posY, this.tiles, this.tiles.!java.util.HashMap.keySet, this.tiles.!java.util.HashSet.map, tile$1.color, tile$1.posX, tile$1.posY, x$0.COLUMNS, y$1.ROWS }
  25 assignment D = { block$3 } U = {  }
  26 assignment D = {  } U = { this.pit.!checkLines( ) }
  27 receiver D = {  } U = { this.pit }
  28 methodCall D = {  } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, t$2.color, t$2.posX, t$2.posY, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.currentBlock.tiles.!java.util.HashMap.keySet, this.currentBlock.tiles.!java.util.HashSet.map, this.height, this.level, this.offg, this.pit.info, this.pit.info.level, this.pit.info.lines, this.posX, this.posY, this.score, this.tile$4.posY, this.width, tile$2.color, tile$2.posX, tile$2.posY, tile$4.color, tile$4.posX, tile$4.posY } TO = Pit#checkLines( )
* actualOut D = { this.color.!java.awt.Color.cs, this.color.!java.awt.Color.falpha, this.color.!java.awt.Color.frgbvalue, this.color.!java.awt.Color.fvalue, this.color.!java.awt.Color.value, this.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.!checkLines( ) } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, t$2.color, t$2.posX, t$2.posY, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.currentBlock.tiles.!java.util.HashMap.keySet, this.currentBlock.tiles.!java.util.HashSet.map, this.height, this.level, this.offg, this.pit.info, this.pit.info.level, this.pit.info.lines, this.posX, this.posY, this.score, this.tile$4.posY, this.width, tile$2.color, tile$2.posX, tile$2.posY, tile$4.color, tile$4.posX, tile$4.posY }
  30 assignment D = { isGameOver$0 } U = { this.pit.!placeNextBlock( ) }
  31 receiver D = {  } U = { this.pit }
  32 methodCall D = {  } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS } TO = Pit#placeNextBlock( )
* actualOut D = { this.pit.!placeNextBlock( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Block.NUMBER_OF, BlueBlock.COLOR, CyanBlock.COLOR, GreenBlock.COLOR, MagentaBlock.COLOR, OrangeBlock.COLOR, Pit.initPosX, Pit.initPosY, RedBlock.color, YellowBlock.COLOR, p$0.box, p$0.currentBlock, p$0.font, p$0.height, p$0.info, p$0.nextBlock, p$0.offImage, p$0.offg, p$0.rnd, p$0.width, this, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.offsetX, this.offsetX.SIZE, this.offsetY, this.offsetY.SIZE, this.pit, this.pit.box, this.pit.currentBlock, this.pit.currentBlock.tile$3.posX, this.pit.currentBlock.tile$3.posY, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.nextBlock, this.pit.rnd, this.pit.rnd.!java.util.Random.seed, this.posX, this.posY, this.tiles, this.tiles.!java.util.HashSet.PRESENT, this.tiles.!java.util.HashSet.map, x$0.COLUMNS, y$1.ROWS }
  34 assignment D = {  } U = { this.info.!update( Block ) }
  35 receiver D = {  } U = { this.info }
  36 methodCall D = {  } U = { Color.black, Color.gray, Color.white, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width } TO = GameInfo#update( Block )
  37 actualIn D = {  } U = { this.pit.!getNextBlock( ) }
  38 receiver D = {  } U = { this.pit }
  39 methodCall D = {  } U = { this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock } TO = Pit#getNextBlock( )
  40 actualOut D = { this.pit.!getNextBlock( ) } U = { this.nextBlock.offsetX, this.nextBlock.offsetY, this.nextBlock.pit, this.nextBlock.posX, this.nextBlock.posY, this.nextBlock.tiles, this.pit.nextBlock }
* actualOut D = { this.info.!update( Block ), this.info.nextBlock$0.tile$2.color.!java.awt.Color.cs, this.info.nextBlock$0.tile$2.color.!java.awt.Color.falpha, this.info.nextBlock$0.tile$2.color.!java.awt.Color.frgbvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.fvalue, this.info.nextBlock$0.tile$2.color.!java.awt.Color.value, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.gray, Color.white, Tile.BORDER, Tile.SIZE, Tile.SIZE.SIZE, nextBlock$0.offsetX, nextBlock$0.offsetY, nextBlock$0.pit, nextBlock$0.posX, nextBlock$0.posY, nextBlock$0.tiles, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.info.font, this.info.height, this.info.level, this.info.lines, this.info.nextBlock$0.offsetX, this.info.nextBlock$0.offsetY, this.info.nextBlock$0.tile$2.color, this.info.nextBlock$0.tile$2.posX, this.info.nextBlock$0.tile$2.posY, this.info.nextBlock$0.tiles, this.info.nextBlock$0.tiles.!java.util.HashMap.keySet, this.info.nextBlock$0.tiles.!java.util.HashSet.map, this.info.offg, this.info.score, this.info.width }
  42 merge ifSt(21)
  43 assignment D = {  } U = { this.pit.!update( ) }
  44 receiver D = {  } U = { this.pit }
  45 methodCall D = {  } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY } TO = Pit#update( )
* actualOut D = { this.color.!java.awt.Color.cs, this.color.!java.awt.Color.falpha, this.color.!java.awt.Color.frgbvalue, this.color.!java.awt.Color.fvalue, this.color.!java.awt.Color.value, this.pit.!update( ), this.pit.currentBlock.tiles.!java.util.HashMap.keySet } U = { Color.black, Color.white, Pit.backgroundColor, Pit.columns, Pit.rows, Tile.BORDER, Tile.SIZE, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.box, this.color, this.currentBlock.offsetX, this.currentBlock.offsetY, this.currentBlock.pit, this.currentBlock.posX, this.currentBlock.posY, this.currentBlock.tiles, this.pit.currentBlock, this.pit.currentBlock.tiles, this.pit.currentBlock.tiles.!java.util.HashMap.keySet, this.pit.currentBlock.tiles.!java.util.HashSet.map, this.pit.height, this.pit.offg, this.pit.width, this.posX, this.posY, tile$2.color, tile$2.posX, tile$2.posY }
  47 ifSt D = {  } U = { isGameOver$0 }
  48 assignment D = {  } U = { this.pit.!gameOver( ) }
  49 receiver D = {  } U = { this.pit }
  50 methodCall D = {  } U = { Color.red, Color.white, Pit.backgroundColor, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.font, this.offg, this.pit.font, this.pit.offg, this.pit.width } TO = Pit#gameOver( )
  51 actualOut D = { this.pit.!gameOver( ) } U = { Color.red, Color.white, Pit.backgroundColor, this.!java.awt.Component.height, this.!java.awt.Component.parent, this.!java.awt.Component.peer, this.!java.awt.Component.width, this.!java.awt.Component.x, this.!java.awt.Component.y, this.font, this.offg, this.pit.font, this.pit.offg, this.pit.width }
  52 assignment D = {  } U = { this.!stopTimer( ) }
  53 receiver D = {  } U = {  }
  54 methodCall D = {  } U = {  } TO = Tetris#stopTimer( )
  55 actualOut D = { this.!stopTimer( ) } U = {  }
  56 merge ifSt(47)
  57 methodExit
  58 formalOut D = {  } U = { $_ }
* actualOut D = { block$3.posY } U = {  }
* actualOut D = { this.pit.box } U = {  }
* actualOut D = { this.tile$2.posY } U = {  }
* actualOut D = { this.level } U = {  }
* actualOut D = { this.pit.info.lines } U = {  }
* actualOut D = { this.score } U = {  }
* actualOut D = { this.box } U = {  }
* actualOut D = { this.tile$4.posY } U = {  }
* actualOut D = { this.offsetX } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.offsetY } U = {  }
* actualOut D = { this.pit.nextBlock.pit } U = {  }
* actualOut D = { super.posX } U = {  }
* actualOut D = { this.pit.currentBlock.posX } U = {  }
* actualOut D = { super.posY } U = {  }
* actualOut D = { this.pit.currentBlock.posY } U = {  }
* actualOut D = { this.pit.currentBlock } U = {  }
* actualOut D = { this.pit.nextBlock } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).color } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posX } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posX } U = {  }
* actualOut D = { this.pit.!placeNextBlock( ).posY } U = {  }
* actualOut D = { this.pit.currentBlock.tile$3.posY } U = {  }
* actualOut D = { this.timer } U = {  }
--
   0: timer
   1:    0 ->    1 trueControlFlow
   2:    1 ->    2 trueControlFlow
--
   0: stopTimer( )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    3 ->    2 trueControlFlow
--
   0: Tetris( )
   1:    0 ->    2 trueControlFlow
   2:    2 ->    1 trueControlFlow
--
   0: init( )
   1:    0 ->    2 trueControlFlow
   2:    1 ->    6 trueControlFlow
   3:    2 ->    3 trueControlFlow
   4:    3 -> * trueControlFlow
   5:    4 ->    1 trueControlFlow
   6:    5 ->   11 trueControlFlow
   7:    6 ->    8 trueControlFlow
   8:    7 -> * trueControlFlow
   9:    8 ->    7 trueControlFlow
  10: * ->    5 trueControlFlow
  11:   10 ->   15 trueControlFlow
  12:   11 ->   12 trueControlFlow
  13:   12 ->   13 trueControlFlow
  14:   13 ->   10 trueControlFlow
  15:   14 ->   22 trueControlFlow
  16:   15 ->   17 trueControlFlow
  17:   16 -> * trueControlFlow
  18:   17 ->   18 trueControlFlow
  19:   18 -> * trueControlFlow
  20: * ->   16 trueControlFlow
  21: * ->   14 trueControlFlow
  22:   21 ->   26 trueControlFlow
  23:   22 ->   23 trueControlFlow
  24:   23 -> * trueControlFlow
  25: * ->   21 trueControlFlow
  26:   25 ->   30 trueControlFlow
  27:   26 ->   27 trueControlFlow
  28:   27 -> * trueControlFlow
  29: * ->   25 trueControlFlow
  30:   29 ->   34 trueControlFlow
  31:   30 ->   31 trueControlFlow
  32:   31 -> * trueControlFlow
  33: * ->   29 trueControlFlow
  34:   33 ->   38 trueControlFlow
  35:   34 ->   35 trueControlFlow
  36:   35 ->   36 trueControlFlow
  37:   36 ->   33 trueControlFlow
  38:   37 ->   42 trueControlFlow
  39:   38 ->   39 trueControlFlow
  40:   39 -> * trueControlFlow
  41: * ->   37 trueControlFlow
  42:   41 ->   46 trueControlFlow
  43:   42 ->   43 trueControlFlow
  44:   43 -> * trueControlFlow
  45: * ->   41 trueControlFlow
  46:   45 ->   50 trueControlFlow
  47:   46 ->   47 trueControlFlow
  48:   47 -> * trueControlFlow
  49: * ->   45 trueControlFlow
  50:   49 ->   58 trueControlFlow
  51:   50 ->   53 trueControlFlow
  52:   51 -> * trueControlFlow
  53:   52 ->   51 trueControlFlow
  54:   53 ->   54 trueControlFlow
  55:   54 ->   55 trueControlFlow
  56:   55 ->   52 trueControlFlow
  57: * ->   49 trueControlFlow
  58:   57 ->   62 trueControlFlow
  59:   58 ->   59 trueControlFlow
  60:   59 -> * trueControlFlow
  61: * ->   57 trueControlFlow
  62:   61 ->   66 trueControlFlow
  63:   62 ->   63 trueControlFlow
  64:   63 -> * trueControlFlow
  65: * ->   61 trueControlFlow
  66:   65 ->   70 trueControlFlow
  67:   66 ->   67 trueControlFlow
  68:   67 ->   68 trueControlFlow
  69:   68 ->   65 trueControlFlow
  70:   70 ->   69 trueControlFlow
  71: * -> * trueControlFlow
  72: * ->    4 trueControlFlow
  73: * -> * trueControlFlow
  74: * -> * trueControlFlow
  75: * -> * trueControlFlow
  76: * -> * trueControlFlow
  77: * -> * trueControlFlow
  78: * -> * trueControlFlow
  79: * -> * trueControlFlow
  80: * -> * trueControlFlow
  81: * -> * trueControlFlow
  82: * -> * trueControlFlow
  83: * -> * trueControlFlow
  84: * -> * trueControlFlow
  85: * -> * trueControlFlow
  86: * -> * trueControlFlow
  87: * -> * trueControlFlow
  88: * -> * trueControlFlow
  89: * -> * trueControlFlow
  90: * -> * trueControlFlow
  91: * -> * trueControlFlow
  92: * -> * trueControlFlow
  93: * -> * trueControlFlow
  94: * -> * trueControlFlow
  95: * -> * trueControlFlow
  96: * -> * trueControlFlow
  97: * -> * trueControlFlow
  98: * -> * trueControlFlow
  99: * -> * trueControlFlow
 100: * -> * trueControlFlow
 101: * -> * trueControlFlow
--
   0: keyTyped( java.awt.event.KeyEvent )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    3 ->    2 trueControlFlow
--
   0: main( java.lang.String[] )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    2 ->    7 trueControlFlow
   4:    3 ->    4 trueControlFlow
   5:    4 ->    5 trueControlFlow
   6:    5 ->    2 trueControlFlow
   7:    6 ->   11 trueControlFlow
   8:    7 ->    8 trueControlFlow
   9:    8 -> * trueControlFlow
  10: * ->    6 trueControlFlow
  11:   11 ->   10 trueControlFlow
  12: * -> * trueControlFlow
  13: * -> * trueControlFlow
  14: * -> * trueControlFlow
  15: * -> * trueControlFlow
  16: * -> * trueControlFlow
  17: * -> * trueControlFlow
  18: * -> * trueControlFlow
  19: * -> * trueControlFlow
  20: * -> * trueControlFlow
  21: * -> * trueControlFlow
  22: * -> * trueControlFlow
  23: * -> * trueControlFlow
  24: * -> * trueControlFlow
  25: * -> * trueControlFlow
  26: * -> * trueControlFlow
  27: * -> * trueControlFlow
  28: * -> * trueControlFlow
  29: * -> * trueControlFlow
  30: * -> * trueControlFlow
  31: * -> * trueControlFlow
  32: * -> * trueControlFlow
  33: * -> * trueControlFlow
  34: * -> * trueControlFlow
  35: * -> * trueControlFlow
  36: * -> * trueControlFlow
  37: * -> * trueControlFlow
  38: * -> * trueControlFlow
  39: * -> * trueControlFlow
  40: * -> * trueControlFlow
  41: * -> * trueControlFlow
--
   0: COLUMNS
   1:    0 ->    1 trueControlFlow
   2:    1 ->    2 trueControlFlow
--
   0: ROWS
   1:    0 ->    1 trueControlFlow
   2:    1 ->    2 trueControlFlow
--
   0: keyReleased( java.awt.event.KeyEvent )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    3 ->    2 trueControlFlow
--
   0: pit
   1:    0 ->    1 trueControlFlow
   2:    1 ->    2 trueControlFlow
--
   0: createTimer( )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    1 ->    6 falseControlFlow
   4:    2 ->    6 trueControlFlow
   5:    3 ->    4 trueControlFlow
   6:    4 -> * trueControlFlow
   7:    5 ->    2 trueControlFlow
   8:    6 ->    8 trueControlFlow
   9:    7 ->   12 trueControlFlow
  10:    8 ->    9 trueControlFlow
  11:    9 -> * trueControlFlow
  12: * ->    7 trueControlFlow
  13:   12 ->   11 trueControlFlow
  14: * ->    5 trueControlFlow
--
   0: info
   1:    0 ->    1 trueControlFlow
   2:    1 ->    2 trueControlFlow
--
   0: keyPressed( java.awt.event.KeyEvent )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    2 ->    6 trueControlFlow
   4:    3 ->    4 trueControlFlow
   5:    4 ->    5 trueControlFlow
   6:    5 ->    2 trueControlFlow
   7:    6 ->    8 trueControlFlow
   8:    6 ->   39 falseControlFlow
   9:    7 ->   12 trueControlFlow
  10:    8 ->    9 trueControlFlow
  11:    9 -> * trueControlFlow
  12: * ->    7 trueControlFlow
  13:   11 ->   16 trueControlFlow
  14:   12 ->   13 trueControlFlow
  15:   13 -> * trueControlFlow
  16:   14 ->   11 trueControlFlow
  17:   15 ->   20 trueControlFlow
  18:   16 ->   17 trueControlFlow
  19:   17 -> * trueControlFlow
  20:   18 ->   15 trueControlFlow
  21:   19 ->   24 trueControlFlow
  22:   20 ->   21 trueControlFlow
  23:   21 -> * trueControlFlow
  24: * ->   19 trueControlFlow
  25:   23 ->   28 trueControlFlow
  26:   24 ->   25 trueControlFlow
  27:   25 -> * trueControlFlow
  28: * ->   23 trueControlFlow
  29:   27 ->   36 trueControlFlow
  30:   28 ->   31 trueControlFlow
  31:   29 -> * trueControlFlow
  32:   30 ->   29 trueControlFlow
  33:   31 ->   32 trueControlFlow
  34:   32 ->   33 trueControlFlow
  35:   33 ->   30 trueControlFlow
  36: * ->   27 trueControlFlow
  37:   35 ->   45 trueControlFlow
  38:   36 ->   37 trueControlFlow
  39:   37 -> * trueControlFlow
  40: * ->   35 trueControlFlow
  41:   39 ->   41 trueControlFlow
  42:   39 ->   44 falseControlFlow
  43:   40 ->   44 trueControlFlow
  44:   41 ->   42 trueControlFlow
  45:   42 ->   43 trueControlFlow
  46:   43 ->   40 trueControlFlow
  47:   44 ->   45 trueControlFlow
  48:   45 ->   46 trueControlFlow
  49:   46 ->   48 trueControlFlow
  50:   46 ->   81 falseControlFlow
  51:   47 ->   51 trueControlFlow
  52:   48 ->   49 trueControlFlow
  53:   49 ->   50 trueControlFlow
  54:   50 ->   47 trueControlFlow
  55:   51 ->   52 trueControlFlow
  56:   52 ->   54 trueControlFlow
  57:   52 ->   58 falseControlFlow
  58:   53 ->   57 trueControlFlow
  59:   54 ->   55 trueControlFlow
  60:   55 -> * trueControlFlow
  61: * ->   53 trueControlFlow
  62:   57 ->   58 fallThroughFlow
  63:   57 ->   76 trueControlFlow
  64:   58 ->   60 trueControlFlow
  65:   58 ->   64 falseControlFlow
  66:   59 ->   63 trueControlFlow
  67:   60 ->   61 trueControlFlow
  68:   61 -> * trueControlFlow
  69: * ->   59 trueControlFlow
  70:   63 ->   64 fallThroughFlow
  71:   63 ->   76 trueControlFlow
  72:   64 ->   66 trueControlFlow
  73:   64 ->   70 falseControlFlow
  74:   65 ->   69 trueControlFlow
  75:   66 ->   67 trueControlFlow
  76:   67 -> * trueControlFlow
  77: * ->   65 trueControlFlow
  78:   69 ->   70 fallThroughFlow
  79:   69 ->   76 trueControlFlow
  80:   70 ->   72 trueControlFlow
  81:   70 ->   76 falseControlFlow
  82:   71 ->   75 trueControlFlow
  83:   72 ->   73 trueControlFlow
  84:   73 -> * trueControlFlow
  85: * ->   71 trueControlFlow
  86:   75 ->   76 trueControlFlow
  87:   75 ->   76 fallThroughFlow
  88:   76 ->   78 trueControlFlow
  89:   77 ->   81 trueControlFlow
  90:   78 ->   79 trueControlFlow
  91:   79 -> * trueControlFlow
  92: * ->   77 trueControlFlow
  93:   81 ->   83 trueControlFlow
  94:   83 ->   82 trueControlFlow
  95: * -> * trueControlFlow
  96: * -> * trueControlFlow
  97: * ->   14 trueControlFlow
  98: * -> * trueControlFlow
  99: * -> * trueControlFlow
 100: * ->   18 trueControlFlow
 101: * -> * trueControlFlow
 102: * -> * trueControlFlow
 103: * -> * trueControlFlow
 104: * -> * trueControlFlow
 105: * -> * trueControlFlow
 106: * -> * trueControlFlow
 107: * -> * trueControlFlow
 108: * -> * trueControlFlow
 109: * -> * trueControlFlow
 110: * -> * trueControlFlow
 111: * -> * trueControlFlow
 112: * -> * trueControlFlow
 113: * -> * trueControlFlow
 114: * -> * trueControlFlow
 115: * -> * trueControlFlow
 116: * -> * trueControlFlow
 117: * -> * trueControlFlow
 118: * -> * trueControlFlow
 119: * -> * trueControlFlow
 120: * -> * trueControlFlow
 121: * -> * trueControlFlow
 122: * -> * trueControlFlow
 123: * -> * trueControlFlow
 124: * -> * trueControlFlow
 125: * -> * trueControlFlow
 126: * -> * trueControlFlow
--
   0: startTimer( )
   1:    0 ->    2 trueControlFlow
   2:    1 ->    6 trueControlFlow
   3:    2 ->    3 trueControlFlow
   4:    3 -> * trueControlFlow
   5: * ->    1 trueControlFlow
   6:    6 ->    5 trueControlFlow
--
   0: run( )
   1:    0 ->    1 trueControlFlow
   2:    1 ->    3 trueControlFlow
   3:    2 ->    6 trueControlFlow
   4:    3 ->    4 trueControlFlow
   5:    4 ->    5 trueControlFlow
   6:    5 ->    2 trueControlFlow
   7:    6 ->    7 trueControlFlow
   8:    6 ->   58 falseControlFlow
   9:    7 ->    9 trueControlFlow
  10:    8 ->   15 trueControlFlow
  11:    9 ->   11 trueControlFlow
  12:   10 ->   14 trueControlFlow
  13:   10 ->   16 exceptionCatchFlow
  14:   11 ->   12 trueControlFlow
  15:   12 ->   13 trueControlFlow
  16:   13 ->   10 trueControlFlow
  17:   14 ->    8 trueControlFlow
  18:   15 ->   18 trueControlFlow
  19:   16 ->   15 trueControlFlow
  20:   16 ->   15 fallThroughFlow
  21:   17 ->   22 trueControlFlow
  22:   18 ->   19 trueControlFlow
  23:   19 ->   20 trueControlFlow
  24:   20 ->   17 trueControlFlow
  25:   21 ->   25 trueControlFlow
  26:   21 ->   42 falseControlFlow
  27:   22 ->   23 trueControlFlow
  28:   23 -> * trueControlFlow
  29: * ->   21 trueControlFlow
  30:   25 ->   27 trueControlFlow
  31:   26 ->   31 trueControlFlow
  32:   27 ->   28 trueControlFlow
  33:   28 -> * trueControlFlow
  34: * ->   26 trueControlFlow
  35:   30 ->   35 trueControlFlow
  36:   31 ->   32 trueControlFlow
  37:   32 -> * trueControlFlow
  38: * ->   30 trueControlFlow
  39:   34 ->   42 trueControlFlow
  40:   35 ->   38 trueControlFlow
  41:   36 -> * trueControlFlow
  42:   37 ->   36 trueControlFlow
  43:   38 ->   39 trueControlFlow
  44:   39 ->   40 trueControlFlow
  45:   40 ->   37 trueControlFlow
  46: * ->   34 trueControlFlow
  47:   42 ->   44 trueControlFlow
  48:   43 ->   47 trueControlFlow
  49:   44 ->   45 trueControlFlow
  50:   45 -> * trueControlFlow
  51: * ->   43 trueControlFlow
  52:   47 ->   49 trueControlFlow
  53:   47 ->   56 falseControlFlow
  54:   48 ->   53 trueControlFlow
  55:   49 ->   50 trueControlFlow
  56:   50 ->   51 trueControlFlow
  57:   51 ->   48 trueControlFlow
  58:   52 ->   56 trueControlFlow
  59:   53 ->   54 trueControlFlow
  60:   54 -> * trueControlFlow
  61:   55 ->   52 trueControlFlow
  62:   56 ->    6 trueControlFlow (L =    6)
  63:   58 ->   57 trueControlFlow
  64: * -> * trueControlFlow
  65: * -> * trueControlFlow
  66: * -> * trueControlFlow
  67: * -> * trueControlFlow
  68: * -> * trueControlFlow
  69: * -> * trueControlFlow
  70: * -> * trueControlFlow
  71: * -> * trueControlFlow
  72: * -> * trueControlFlow
  73: * -> * trueControlFlow
  74: * -> * trueControlFlow
  75: * -> * trueControlFlow
  76: * -> * trueControlFlow
  77: * -> * trueControlFlow
  78: * -> * trueControlFlow
  79: * -> * trueControlFlow
  80: * -> * trueControlFlow
  81: * -> * trueControlFlow
  82: * -> * trueControlFlow
  83: * -> * trueControlFlow
  84: * -> * trueControlFlow
  85: * -> * trueControlFlow
  86: * -> * trueControlFlow
  87: * -> * trueControlFlow
  88: * -> * trueControlFlow
  89: * -> * trueControlFlow
  90: * ->   55 trueControlFlow
--
----- CCFG (to here) -----

